%start preamble
\documentclass[paper=a4,fontsize=11pt]{scrartcl}%kind of doc, font size, paper size

\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
%\setsansfont{Liberation Sans}
\usepackage{polyglossia}	
\setdefaultlanguage[spelling=new, babelshorthands=true]{german}
			
\usepackage{amsmath}%get math done
\usepackage{amsthm}%get theorems and proofs done
\usepackage{graphicx}%get pictures & graphics done
\graphicspath{{pictures/}}%folder to stash all kind of pictures etc
\usepackage{amssymb}%symbolics for math
\usepackage{amsfonts}%extra fonts
\usepackage{caption}%captions under everything
\usepackage{listings}
\numberwithin{equation}{section} 
\usepackage{float}%for garphics and how to let them floating around in the doc
\usepackage{xcolor}%nicer colors, here used for links
\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{csquotes}
\usepackage{enumitem}
\usepackage{pythonhighlight}

\usepackage[backend=biber,style=alphabetic,
citestyle=alphabetic]{biblatex} %biblatex mit biber laden
\addbibresource{sources.bib}

%settings colors for links
\hypersetup{
    colorlinks,
    linkcolor={blue!50!black},
    citecolor={blue},
    urlcolor={blue!80!black}
}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}


\pagestyle{fancy}
\lhead{NW+VS -- Übung\\WiSe 2021/22}
\rhead{FB 4 -- IKG \\ HTW-Berlin}
\lfoot{Übungsblatt 03}
\cfoot{}
\fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\lstdefinestyle{Bash}{
  language=bash,
  showstringspaces=false,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  frame=trlb,
  columns=fullflexible,
  backgroundcolor=\color{gray!20},
  linewidth=0.9\linewidth,
  %xleftmargin=0.5\linewidth
}


%%here begins the actual document%%
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height


\begin{document}
\begin{center}
\Large{\textbf{Übungsblatt 3 -- Einfache verteilte System mit Sockets und HTTP}}
\end{center}

\begin{center}\Large{\textbf{Aufgabe A -- HTTP}}\end{center}
~\\
Nachdem wir in der letzten Übung bereits erste Erfahrungen mit \emph{HTTP} gemacht haben, wollen wir etwas tiefer in Richtung verteilte Systeme vorstoßen. Dazu nutzen wir weiterhin \emph{HTTP}.
\begin{enumerate}
	\item \emph{HTTP} arbeitet mit Nachrichten im Request-Response-Schema. D.h. ein Client sendet Anfragen an den Server, der Server antwortet auf die eingehenden Anfragen.
	\begin{enumerate}
		\item Im Folgenden ist ein \emph{HTTP}-Request abgebildet:
		\begin{figure}[H]
	\includegraphics[scale=0.4]{http_req}
	\end{figure}
	Erläutern sie den Aufbau solch einer \emph{HTTP}-Nachricht.
	\item Im Folgenden ist eine \emph{HTTP}-Response abgebildet.
	\begin{figure}[H]
	\includegraphics[scale=0.4]{http_resp}
	\end{figure}
	Erläutern sie den Aufbau der prototypischen \emph{HTTP}-Nachricht.
	\end{enumerate}
	\item \emph{HTTP} ist gehört zu zustandslosen Protokollen. Jedoch kodiert der Server bei jeder Antwort die Art des Response.\\
	\emph{HTTP} hält generell fünf Typen von Status-Codes (Response-Codes) vor, die erste Ziffer gibt den Typ des Codes an. Recherchieren sie kurz, was folgenden Status-Codes bedeuten:
	\begin{enumerate}
		\item \textit{1yy} 
		\item \textit{2yy}
		\item \textit{3yy}
		\item \textit{4yy}
		\item \textit{5yy}    
	\end{enumerate}
\end{enumerate}

\begin{center}\Large{\textbf{Aufgabe B -- Scapy}}\end{center}
~\\
In der kommenden Übung arbeiten wir unter anderem mit \emph{Scapy}. Mithilfe von \emph{Scapy} können einfach Pakte gebaut, analysiert und verändert werden. So auch \emph{HTTP}-Pakete. Der Vorteil ist, dass sie nicht die darunter liegenden Schichten abarbeiten müssen, dass erledigt \emph{Scapy} für sie transparent.
\begin{enumerate}
	\item Innerhalb \emph{Scapys} können sie sich den Aufbau verschiedener Paketen anzeigen lassen. Geben hierfür einfach \texttt{load\_layers("NAME")} ein.
	\item Lesen sie den nachfolgenden Code und kommentieren sie sich, wie ein \emph{HTTP}-Request und -Response umgesetzt werden sollten.
	\begin{python}
>>> load_layer("http")
>>> HTTPRequest().show()
###[ HTTP Request ]### 
  Method    = 'GET'
  Path      = '/'
  Http_Version= 'HTTP/1.1'
  A_IM      = None
  Accept    = None
  Accept_Charset= None
  Accept_Datetime= None
  Accept_Encoding= None
  Accept_Language= None

  [...]
\end{python} 


\begin{python}
>>> HTTPResponse().show()
###[ HTTP Response ]###
  Http_Version= 'HTTP/1.1'
  Status_Code= '200'
  Reason_Phrase= 'OK'
  Accept_Patch43= None
  Accept_Ranges= None
  [...]
\end{python}
\end{enumerate}

\begin{center}\Large{\textbf{Aufgabe C -- Python}}\end{center}
~\\
Im Folgenden ist ein einfacher Chat-Server in der Programmiersprache \emph{Python} implementiert worden. Ihre Aufgabe ist es den Code an den markanten Stellen zu verstehen.
\begin{enumerate}
	\item Lesen sie den Code zunächst einmal von oben nach unten. Markieren sie sich ggf. erste Funktionalitäten.
	\item Ein \emph{\#} markiert den Beginn eines Kommentars. Fügen sie an den entsprechen Stellen Kommentare ein, die erklären, was der Code macht (D.h dort wo \enquote{\# COMPLETE ME} steht).\\
	Kommentieren sie den Code des Chat-Servers!
\begin{python}
!#/usr/local/bin/python3.8
import socket
import select
import threading
import sys


server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
"""
the first argument AF_INET is the address domain of the socket. This is used when we have an Internet Domain
with any two hosts
The second argument is the type of socket. SOCK_STREAM means that data or characters are read in a continuous flow
"""
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

IP_address = "IP_ADDR"
Port = PORT
server.bind((IP_address, Port)) 
#binds the server to an entered IP address and at the specified port number. The client must be aware of these parameters
server.listen(100)
#listens for 100 active connections. This number can be increased as per convenience
list_of_clients=[]

def clientthread(conn, addr):
    conn.send("Welcome to this chatroom!".encode())
    #sends a message to the client whose user object is conn
    while True:
            try:     
                message = conn.recv(2048)    
                if message:
                    print("<" + addr[0] + "> " + message)
                    message_to_send = "<" + addr[0] + "> " + message
                    broadcast(message_to_send,conn)
                    #prints the message and address of the user who just sent the message on the server terminal
                else:
                    remove(conn)
            except:
                continue

def broadcast(message,connection):
    for clients in list_of_clients:
        if clients!=connection:
            try:
                clients.send(message)
            except:
                clients.close()
                remove(clients)

def remove(connection):
    if connection in list_of_clients:
        list_of_clients.remove(connection)

while True:
    conn, addr = server.accept()
    """
    Accepts a connection request and stores two parameters, conn which is a socket object for that user, and addr which contains
    the IP address of the client that just connected
    """
    list_of_clients.append(conn)
    print(addr[0] + " connected")
    #maintains a list of clients for ease of broadcasting a message to all available people in the chatroom
    #Prints the address of the person who just connected
    threading.Thread(target=clientthread(conn,addr))
    #creates and individual thread for every user that connects

conn.close()
server.close()
\end{python}
	\item Analog zu letzten Aufgabe: Lesen und kommentieren sie den Client-Code.
	\begin{python}
!#/usr/local/bin/python3.8
# Python program to implement client side of chat room.
import socket
import select
import sys

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

IP_address = "IP_ADDR"
Port = PORT
server.connect((IP_address, Port))

while True:
    sockets_list = [sys.stdin, server]
    read_sockets,write_socket, error_socket = select.select(sockets_list, [], [])
    for socks in read_sockets:
        if socks == server:
            message = socks.recv(2048)
            print(message)
        else:
            message = sys.stdin.readline()
            server.send(message.encode())
            sys.stdout.write("<You>")
            sys.stdout.write(message)
            sys.stdout.flush()
server.close()
	\end{python}
\end{enumerate}

\printbibliography

\end{document}
